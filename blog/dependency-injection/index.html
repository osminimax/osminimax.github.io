<!doctype html><html lang=ko><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Dependency Injection에 대한 작은 깨달음</title><meta content="<p>오늘 드디어 작은 깨달음을 얻었다. Dependency Injection은 Gof 디자인 패턴에서 말하던 객체 합성(object composition)의 구체적이고 실제적인 디자인 패턴이었다.</p>" name=description><link href=/icons/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/icons/site.webmanifest rel=manifest><link color=#5bbad5 href=/icons/safari-pinned-tab.svg rel=mask-icon><link rel="shortcut icon" href=/icons/favicon.ico><meta content=#00aba9 name=msapplication-TileColor><meta content=/icons/browserconfig.xml name=msapplication-config><meta content=#ffffff name=theme-color><link href=https://osminimax.github.io/styles/styles.css rel=stylesheet><script>if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.documentElement.classList.add('dark')
    localStorage.setItem("theme", "dark")
  } else {
    document.documentElement.classList.remove('dark')
    localStorage.setItem("theme", "light")
  }</script><link href=https://osminimax.github.io/hl-light.css id=hl rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-6RNN1QTK5S" async></script><script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-6RNN1QTK5S');</script><body class="antialiased text-slate-700 dark:text-slate-300 bg-white dark:bg-stone-900"><header><div class="bg-stone-300 dark:bg-stone-700 py-1"><div class="row justify-between max-w-prose m-auto px-5"><nav class="row items-center gap-2"><div><a class=text-xl href=https://osminimax.github.io>osminimax</a><span class=text-xl> > </span><a class=text-xl href=https://osminimax.github.io/blog>blog</a><span class=text-xl> > </span><a class=text-xl href=https://osminimax.github.io/blog/dependency-injection>dependency-injection</a></div></nav><div class="row items-center gap-3"><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg>' id=theme-toggle><svg class="w-6 h-6" viewbox="0 0 24 24" fill=none stroke=currentColor stroke-width=1.5 xmlns=http://www.w3.org/2000/svg><path d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" stroke-linecap=round stroke-linejoin=round /></svg></button></div></div></div></header><div class="flex justify-center items-center w-full"><main class="max-w-prose px-4 w-full"><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
</svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184" />
</svg>' id=copy-cfg style=display:none></div><article class="col w-full" data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 19.5l-15-15m0 0v11.25m0-11.25h11.25" />
</svg>' id=post><section aria-label="Article Info" class="col pt-7 gap-4 mb-10"><h1 class=text-2xl>Dependency Injection에 대한 작은 깨달음</h1><div class="row justify-between"><div><span class="text-lg text-stone-400" id=publish>2022-04-18</span></div><div class="flex gap-2"><a class="text-lg tl-link" href=https://osminimax.github.io/tags/one># one</a><a class="text-lg tl-link" href=https://osminimax.github.io/tags/two># two</a><a class="text-lg tl-link" href=https://osminimax.github.io/tags/three># three</a></div></div></section><section aria-label=Article class=tl-prose><p>오늘 드디어 작은 깨달음을 얻었다. Dependency Injection은 Gof 디자인 패턴에서 말하던 객체 합성(object composition)의 구체적이고 실제적인 디자인 패턴이었다.</p><span id=continue-reading></span><p>OOP에서 재사용, 즉 OCP(Open Close Principle)을 만족시키기 위해 사용하는 기법은 클래스 상속(is-a)과 객체 합성(has-a)이 대표적이다. 클래스 상속은 뭐 기초니까 넘어가고, 객체 합성은 인터페이스가 명확히 정의된 ’객체’를 서로 묶어서 사용하는 기법인데, 일반적으로 객체 합성이 클래스 상속보다 나은 기법으로 평가받는다.<p>그 이유로는 다음과 같은 장점이 있다.<ol><li><p>클래스 상속은 은닉성을 해친다. 오버라이딩 등 부모 클래스의 행동과 데이터에 대한 직접적인 수정은 절대적으로 부모 클래스에 의존하게 만든다. 만약의 경우 부모 클래스가 수정되는 경우, 그 부모 클래스를 상속받은 클래스들은 전부 수정이 필요한 쓰레기가 되어 버리는 것이다.</p><li><p>합성은 ’런타임’에 동적으로 정의된다. 합성은 런타임에서 객체가 <strong>인터페이스를 아는</strong> 다른 객체를 참조하는 것으로 구현하니까, 인터페이스가 호환되는 객체라면 아무거나 쓸 수 있다. 즉 상속으로는 구현할 수 없는 유연함을 기본적으로 가질 수 있다는 뜻이다.</p><li><p>그렇기 때문에 인터페이스 호환이 문서에서 보장되는 객체라면 코드를 까볼 필요 없이 그냥 가져다 쓸 수 있다. 이는 엄청난 비용의 절감, 즉 OOP에서 목놓아 부르짖는 캡슐화와 재사용을 의미한다.</p></ol><p>당연히 이런 장점들을 제대로 쓰기 위해서는 클래스 안에서 직접 합성할 인스턴스를 생성하는 멍청한 방법이 아닌, 밖에서 생성된 인스턴스를 인자로 입력받아 써야 한다. 이건 한 객체가 다른 객체에 대한 <strong>참조</strong> 를 얻는 방식으로 런타임에 동적으로 정의한다는 말을 쉽게 다시 풀어쓴 부분이다.<p>이걸 명확하게 만든 게 DI다. Product 타입의 어떤 클래스에서 구현된 기능을 사용하는 Store 객체를 동적으로 만들기 위해,<p>Product 인터페이스, Product 인터페이스의 구현체인 Gun, Aspirin, Pizza, Cup 클래스가 있다고 가정하자.<p>외부에서 해당 구현체의 인스턴스 중 비즈니스 로직에 맞는 <strong>인스턴스(=예시)</strong> 를 그냥 Store 인스턴스에 인자로 푝 주입해주면 스팀팩 맞은 것처럼 개발자의 생산성이 올라가게 되는 것이다. (아마 수명도 늘어날듯)<p>https://www.jamesshore.com/v2/blog/2006/dependency-injection-demystified 이 글을 지금 찾았는데, 이 표현에 전적으로 동의한다. 5센트짜리 개념을 위한 25달러짜리 용어. DI는 걍 객체에 인스턴스 변수를 넣어주는 거임. 그게 다임.<p>용어는 뒤지게 어려운데 막상 이해하고 나면 간단한 거여서 현타가 좀 왔다.<p>그런데 DI를 설명한 글들을 보면 IoC(Inversion of Control, 제어의 역전)과 개념을 혼동하는 경우가 많은 것 같다.<p>먼가 먼가 이상해서 열심히 구글링을 해 보니, 국내뿐만 아니라 스택오버플로에서도 개념의 혼동이 가득한 것을 확인할 수 있었다.<p>https://stackoverflow.com/questions/3058/what-is-inversion-of-control<p>그래서 개같이 넓은 구글에서 표류당할 뻔한 순간, IoC를 hollywood principle이라고도 한다는 것을 발견했다.<p>그리고 hollywood principle을 검색하자마자 양질의 자료가 뿜어져 나왔다.<p>또 Gof가 나와서 깜짝 놀랐는데, 템플릿 메소드 패턴 챕터에서 처음으로 언급된 개념이라고 한다.<blockquote><p>Template methods lead to an inverted control structure that’s sometimes referred to as “the Hollywood principle,” that is, “Don’t call us, we’ll call you”.<p>템플릿 메소드는 “할리우드 원칙”, 즉 “전화하지 마. 우리가 전화할게.“라는 역전된 제어 구조를 이끌어낸다.</blockquote><p>이걸 보자마자 어? 이거 콜백 아니냐? 라는 생각이 들어서 더욱 의심이 확고해졌다.<p>https://johngrib.github.io/wiki/hollywood-principle/<p>여기서 명확히 모든 것이 드러나는데, Inversion of control이라는 용어가 명확히 사용된 첫 논문인 Object-Oriented Frameworks: A survey of methodological issues, p.98에서 할리우드 원칙 == 제어의 역전에 대해서 명확히 정의한 것을 볼 수 있다.<p>그러니까 어휘 그대로, 제어의 역전은 객체의 제어의 주도권이 역전되는 현상, 즉 프레임워크와 라이브러리(혹은 툴킷)의 차이점에 대한 지적이다. 객체지향 프레임워크에서 프레임워크가 애플리케이션 코드를 호출하여 객체의 처리를 담당하는 부분을 제어의 역전이라고 명명한 것이다.<p>이후 마틴 파울러가 https://martinfowler.com/articles/injection.html 에서 “IoC는 프레임워크의 일반적인 특징이라 너무 포괄적인 용어니까, 스프링 경량 컨테이너가 IoC 써서 특별하다고 말하면 우리 차에 바퀴가 달려서 특별하다고 말하는 느낌임ㅇㅇ. 그래서 다양한 IoC 옹호자들이랑 쎄쎄쎄를 좀 해봤는데, 우리가 스프링에서 쓰는 이 패턴을 Dependency Injection이라고 카면 어때염?”<p>하고 명확하게 써 놨는데 문해력 딸리는 개발자들이 DI ⊂ IoC 를 DI == IoC로 알아먹어 버려서 이런 대참사가 나 버린 것이다.<p>즉, DI = 객체 합성 + 외부 객체 관리 컨테이너 패턴, 객체지향 프레임워크 특징인 IoC를 스프링 프레임워크에서 구현한 구체적 패턴이다.<p><img alt="학교 노을" src=https://osminimax.github.io/blog/dependency-injection/photo_univ2.avif><p>세줄요약하면,<ol><li>세상은 자바 스프링만으로 돌아가지 않는다. 자바공화국 블로그 글들을 너무 믿지 말자.<li>스택오버플로도 똑같이 사람 사는 동네니까 성경처럼 맹신하면 ㅈ된다. 결국 양키 지식in일 뿐이다.<li>제발 가능하면 원서&원글을 보자. 번역 개떡처럼 해 놓고 번역비 먹는 교수들은 언젠가 벌받을 것이다.</ol><p>농담이고,<ol><li>Dependency Injection은 런타임 유연성을 위해 객체에 인스턴스 인자를 외부에서 넣어주는 기법, 즉 객체 합성의 구체적인 디자인 패턴이다.<li>IoC는 엄밀하게는 객체지향 프레임워크의 특징 중 하나지만 스프링에서는 DI(객체 합성 + 컨테이너에서 객체 관리)로 IoC를 구현함</ol></section></article><hr class="h-px my-10 bg-slate-700 dark:bg-slate-300"><section aria-label="Subscription call-to-action"></section><div class="flex justify-center my-16"><button aria-label="back to top" id=back-to-top><svg class="w-6 h-6" viewbox="0 0 24 24" fill=none stroke=currentColor stroke-width=1.5 xmlns=http://www.w3.org/2000/svg><path d="M12 19.5v-15m0 0l-6.75 6.75M12 4.5l6.75 6.75" stroke-linecap=round stroke-linejoin=round /></svg></button></div><footer class="text-stone-400 dark:text-stone-400 row my-16 text-center"><div class=basis-full><p>© 2025 osminimax</div></footer></main></div><script src=https://osminimax.github.io/js/post.js></script><script src=https://osminimax.github.io/js/lightense.min.js></script><script src=https://osminimax.github.io/js/main.js></script>